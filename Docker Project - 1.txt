Project layout
pgsql
example-voting-app/
‚îú‚îÄ docker-compose.yml
‚îú‚îÄ swarm-stack.yml               # (for Swarm: use your pushed images)
‚îú‚îÄ db/
‚îÇ  ‚îî‚îÄ init.sql
‚îú‚îÄ vote/
‚îÇ  ‚îú‚îÄ app.py
‚îÇ  ‚îú‚îÄ requirements.txt
‚îÇ  ‚îú‚îÄ Dockerfile
‚îÇ  ‚îî‚îÄ templates/
‚îÇ     ‚îî‚îÄ index.html
‚îú‚îÄ worker/
‚îÇ  ‚îú‚îÄ worker.py
‚îÇ  ‚îú‚îÄ requirements.txt
‚îÇ  ‚îî‚îÄ Dockerfile
‚îî‚îÄ result/
   ‚îú‚îÄ app.py
   ‚îú‚îÄ requirements.txt
   ‚îú‚îÄ Dockerfile
   ‚îî‚îÄ templates/
      ‚îî‚îÄ index.html

docker-compose.yml
version: "3.9"

services:
  redis:
    image: redis:7-alpine

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql:ro

  vote:
    build: ./vote
    environment:
      REDIS_HOST: redis
      REDIS_PORT: "6379"
    ports:
      - "5000:80"
    depends_on: [redis]

  worker:
    build: ./worker
    environment:
      REDIS_HOST: redis
      REDIS_PORT: "6379"
      POSTGRES_HOST: db
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    depends_on: [redis, db]

  result:
    build: ./result
    environment:
      POSTGRES_HOST: db
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5001:80"
    depends_on: [db]

volumes:
  db_data:

swarm-stack.yml (use after building & pushing images)

Replace yourdockerhub with your repo and tag (e.g., abhishekspark/vote:v1).

version: "3.9"
services:
  redis:
    image: redis:7-alpine
    networks: [vote_net]

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks: [vote_net]

  vote:
    image: yourdockerhub/vote:v1
    environment:
      REDIS_HOST: redis
      REDIS_PORT: "6379"
    ports:
      - "5000:80"
    depends_on: [redis]
    networks: [vote_net]

  worker:
    image: yourdockerhub/worker:v1
    environment:
      REDIS_HOST: redis
      REDIS_PORT: "6379"
      POSTGRES_HOST: db
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    depends_on: [redis, db]
    networks: [vote_net]

  result:
    image: yourdockerhub/result:v1
    environment:
      POSTGRES_HOST: db
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5001:80"
    depends_on: [db]
    networks: [vote_net]

volumes:
  db_data:

networks:
  vote_net:
    driver: overlay

db/init.sql
-- Creates a simple table to store votes
CREATE TABLE IF NOT EXISTS votes (
  id BIGSERIAL PRIMARY KEY,
  choice TEXT NOT NULL CHECK (choice IN ('cats','dogs')),
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

VOTE SERVICE (Flask)
vote/app.py
from flask import Flask, render_template, request, redirect, url_for
import os
import redis

app = Flask(__name__)

REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
QUEUE_NAME = os.getenv("QUEUE_NAME", "votes")

r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)

@app.route("/", methods=["GET"])
def index():
    return render_template("index.html")

@app.route("/vote", methods=["POST"])
def vote():
    choice = request.form.get("vote")
    if choice not in ("cats", "dogs"):
        return "Invalid vote", 400
    # push vote onto Redis list (queue)
    r.rpush(QUEUE_NAME, choice)
    return redirect(url_for("index"))

@app.route("/healthz")
def health():
    try:
        r.ping()
        return "ok", 200
    except Exception as e:
        return f"redis error: {e}", 500

if __name__ == "__main__":
    # Flask dev server (simple for demo); for prod use gunicorn/uwsgi
    app.run(host="0.0.0.0", port=80)

vote/requirements.txt
Flask==3.0.3
redis==5.0.7

vote/Dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY app.py ./app.py
COPY templates ./templates
EXPOSE 80
CMD ["python", "app.py"]

vote/templates/index.html
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Vote: Cats vs Dogs</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;max-width:640px;margin:40px auto;padding:0 16px}
    .card{border:1px solid #ddd;border-radius:12px;padding:24px}
    button{font-size:18px;padding:12px 18px;border-radius:10px;border:1px solid #ccc;cursor:pointer;margin-right:10px}
  </style>
</head>
<body>
  <h1>Vote üó≥Ô∏è</h1>
  <p>Which do you like more?</p>
  <div class="card">
    <form method="post" action="/vote">
      <button name="vote" value="cats" type="submit">üê± CATS</button>
      <button name="vote" value="dogs" type="submit">üê∂ DOGS</button>
    </form>
  </div>
  <p style="margin-top:16px">See results at <code>/result</code> service (port 5001).</p>
</body>
</html>

WORKER SERVICE (Python)

Consumes votes from Redis list and writes to Postgres.

worker/worker.py
import os
import time
import redis
import psycopg2
import psycopg2.extras

REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
QUEUE_NAME = os.getenv("QUEUE_NAME", "votes")

PG_HOST = os.getenv("POSTGRES_HOST", "db")
PG_DB = os.getenv("POSTGRES_DB", "postgres")
PG_USER = os.getenv("POSTGRES_USER", "postgres")
PG_PASS = os.getenv("POSTGRES_PASSWORD", "postgres")

def pg_connect():
    while True:
        try:
            conn = psycopg2.connect(
                host=PG_HOST, dbname=PG_DB, user=PG_USER, password=PG_PASS
            )
            conn.autocommit = True
            return conn
        except Exception as e:
            print("Postgres not ready yet:", e)
            time.sleep(2)

def ensure_table(conn):
    with conn.cursor() as cur:
        cur.execute("""
            CREATE TABLE IF NOT EXISTS votes (
              id BIGSERIAL PRIMARY KEY,
              choice TEXT NOT NULL CHECK (choice IN ('cats','dogs')),
              created_at TIMESTAMP NOT NULL DEFAULT NOW()
            )
        """)

def main():
    r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)
    conn = pg_connect()
    ensure_table(conn)
    print("Worker started. Waiting for votes...")

    while True:
        try:
            item = r.blpop(QUEUE_NAME, timeout=5)  # (queue, value)
            if not item:
                continue
            _, vote = item
            if vote not in ("cats", "dogs"):
                print("Skipping invalid vote:", vote)
                continue
            with conn.cursor() as cur:
                cur.execute("INSERT INTO votes (choice) VALUES (%s)", (vote,))
            print("Recorded vote:", vote)
        except psycopg2.Error as e:
            print("Postgres error:", e)
            conn = pg_connect()  # reconnect
        except Exception as e:
            print("Worker loop error:", e)
            time.sleep(1)

if __name__ == "__main__":
    main()

worker/requirements.txt
redis==5.0.7
psycopg2-binary==2.9.9

worker/Dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY worker.py .
CMD ["python", "worker.py"]

RESULT SERVICE (Flask)

Queries Postgres and shows tallies.

result/app.py
from flask import Flask, render_template
import os
import psycopg2

app = Flask(__name__)

PG_HOST = os.getenv("POSTGRES_HOST", "db")
PG_DB = os.getenv("POSTGRES_DB", "postgres")
PG_USER = os.getenv("POSTGRES_USER", "postgres")
PG_PASS = os.getenv("POSTGRES_PASSWORD", "postgres")

def get_counts():
    conn = psycopg2.connect(host=PG_HOST, dbname=PG_DB, user=PG_USER, password=PG_PASS)
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT choice, COUNT(*) FROM votes GROUP BY choice")
            rows = cur.fetchall()
            counts = {"cats": 0, "dogs": 0}
            for c, n in rows:
                counts[c] = n
            return counts
    finally:
        conn.close()

@app.route("/")
def index():
    counts = get_counts()
    total = counts["cats"] + counts["dogs"]
    return render_template("index.html", counts=counts, total=total)

@app.route("/healthz")
def health():
    try:
        _ = get_counts()
        return "ok", 200
    except Exception as e:
        return f"db error: {e}", 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)

result/requirements.txt
Flask==3.0.3
psycopg2-binary==2.9.9

result/Dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY app.py ./app.py
COPY templates ./templates
EXPOSE 80
CMD ["python", "app.py"]

result/templates/index.html
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Results: Cats vs Dogs</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;max-width:720px;margin:40px auto;padding:0 16px}
    .card{border:1px solid #ddd;border-radius:12px;padding:24px}
    .row{display:flex;gap:16px}
    .box{flex:1;border:1px solid #eee;border-radius:10px;padding:16px;text-align:center}
    h1{margin-bottom:8px}
  </style>
</head>
<body>
  <h1>Results üìä</h1>
  <div class="card">
    <div class="row">
      <div class="box">
        <div style="font-size:48px;">üê±</div>
        <h2>Cats</h2>
        <div style="font-size:28px;">{{ counts['cats'] }}</div>
      </div>
      <div class="box">
        <div style="font-size:48px;">üê∂</div>
        <h2>Dogs</h2>
        <div style="font-size:28px;">{{ counts['dogs'] }}</div>
      </div>
    </div>
    <p style="margin-top:16px">Total votes: <b>{{ total }}</b></p>
  </div>
</body>
</html>

How to run (quick)

From the project root:

docker compose up --build


Open:

Vote UI ‚Üí http://localhost:5000

Result UI ‚Üí http://localhost:5001

(Click buttons on the Vote page; refresh the Result page to see counts update.)

Deploying on Swarm (your EC2)
# In each service dir, build & push
docker build -t yourdockerhub/vote:v1 ./vote
docker push yourdockerhub/vote:v1

docker build -t yourdockerhub/worker:v1 ./worker
docker push yourdockerhub/worker:v1

docker build -t yourdockerhub/result:v1 ./result
docker push yourdockerhub/result:v1

# On the Swarm manager, deploy:
docker stack deploy -c swarm-stack.yml voteapp